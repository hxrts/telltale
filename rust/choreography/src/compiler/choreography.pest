// Choreographic DSL Grammar (new direct-style syntax)

WHITESPACE = _{ " " | "\t" | "\r" | "\n" | COMMENT }
COMMENT = _{ "//" ~ (!"\n" ~ ANY)* ~ ("\n" | EOI) | "/*" ~ (!"*/" ~ ANY)* ~ "*/" }

// Top-level choreography definition
choreography = {
    SOI ~ module_decl? ~ import_decl* ~ protocol_decl ~ EOI
}

// Module and imports (optional)
module_decl = { "module" ~ ident ~ "exposing" ~ "(" ~ expose_list? ~ ")" }
import_decl = { "import" ~ ident ~ ("as" ~ ident)? ~ ("exposing" ~ "(" ~ expose_list? ~ ")")? }
expose_list = { (!")" ~ ANY)* }

// Protocol definitions
protocol_decl = { "protocol" ~ ident ~ header_roles? ~ "=" ~ protocol_body ~ where_block? }
where_block = { "where" ~ locals_block }
locals_block = { "{" ~ local_protocol_decl+ ~ "}" | "(" ~ local_protocol_decl+ ~ ")" | local_protocol_decl+ }
local_protocol_decl = { "protocol" ~ ident ~ header_roles? ~ "=" ~ protocol_body }

header_roles = { "(" ~ role_list ~ ")" }

// Roles declaration
roles_decl = { "roles" ~ role_list }
role_list = { role_decl ~ ("," ~ role_decl)* }
role_decl = { ident ~ role_param? }
role_param = { "[" ~ role_param_expr ~ "]" }
role_param_expr = { integer | ident | "*" }

// Protocol body (sequence of statements)
protocol_body = { block_protocol }
block_protocol = { "{" ~ roles_decl? ~ statement* ~ "}" | "(" ~ roles_decl? ~ statement+ ~ ")" }

// Statement types
statement = _{
    send_stmt
    | broadcast_stmt
    | choice_stmt
    | loop_stmt
    | branch_stmt
    | rec_stmt
    | continue_stmt
    | call_stmt
}

// Protocol call statement (for sub-protocols in where blocks)
call_stmt = { "call" ~ ident }

// Continue statement (for recursive back-references)
continue_stmt = { "continue" ~ ident }

// Send statement
send_stmt = { role_ref ~ "->" ~ role_ref ~ ":" ~ message }

// Broadcast statement
broadcast_stmt = { role_ref ~ "->*" ~ ":" ~ message }

// Role reference (can be simple or indexed)
role_ref = { ident ~ role_index? }
role_index = { "[" ~ role_index_expr ~ "]" }
role_index_expr = { range_expr | integer | ident | "*" }
range_expr = { (integer | ident) ~ ".." ~ (integer | ident) }

// Choice statement
choice_stmt = { choice_head ~ choice_block }
choice_head = { ("case" ~ "choose" ~ role_ref ~ "of") | ("choice" ~ "at" ~ role_ref) }
choice_block = { block_choice }
block_choice = { "{" ~ choice_branch+ ~ "}" | "(" ~ choice_branch+ ~ ")" }
choice_branch = { ident ~ guard? ~ "->" ~ block }

// Guard condition for choice branches
guard = { "when" ~ "(" ~ guard_expr ~ ")" }
guard_expr = { (!")" ~ ANY)+ }

// Loop statement
loop_stmt = { "loop" ~ loop_spec ~ block }
loop_spec = { loop_decide | loop_repeat | loop_while | loop_forever }
loop_decide = { "decide" ~ "by" ~ role_ref }
loop_repeat = { "repeat" ~ int_expr }
loop_while = { "while" ~ string }
loop_forever = { "forever" }
int_expr = { integer | ident }

// Parallel branch statement
branch_stmt = { "branch" ~ block }

// Recursive protocol
rec_stmt = { "rec" ~ ident ~ block }

// Block
block = { "{" ~ statement* ~ "}" | "(" ~ statement+ ~ ")" }

// Message specification
message = { ident ~ message_type? ~ payload? }
message_type = { "<" ~ type_spec ~ ("," ~ type_spec)* ~ ">" }
type_spec = { type_path ~ type_generics? }
type_path = { ident ~ ("::" ~ ident)* }
type_generics = { "<" ~ type_spec ~ ("," ~ type_spec)* ~ ">" }

payload = { payload_paren | payload_brace }
payload_paren = { "(" ~ (!")" ~ ANY)* ~ ")" }
payload_brace = { "{" ~ (!"}" ~ ANY)* ~ "}" }

// Basic tokens
ident = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }
integer = @{ ASCII_DIGIT+ }
string = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }
