-- Lightweight choreography data model consumed by the Lean runner.
/-! Provides a lightweight choreography representation used by the Lean runner.
    Each entry keeps track of roles and flat actions so the runner can validate
    projected local types and action traces emitted by the exporter. -/

namespace Rumpsteak

/- Role information mirrors the Rust AST so Lean can look up role metadata. -/
structure Role where
  name : String
deriving Inhabited, Repr, DecidableEq, BEq

/- Each action unfolds as `(origin, destination, label)` so Lean can inspect the
   flat trace generated by the exporter. -/
abbrev Action := String × String × String

-- Convenience field accessors for tuple-backed actions.
def Action.origin (act : Action) : String := act.fst
def Action.destination (act : Action) : String := (act.snd : String × String).fst
def Action.label (act : Action) : String := (act.snd : String × String).snd

/- Choreography is just a list of roles and their flat actions; helpers build traces. -/
structure Choreography where
  roles : List Role
  actions : List Action
deriving Inhabited, Repr

def roleNames (ch : Choreography) : List String :=
  ch.roles.map (·.name)  /- Extract the role identifiers. -/

def findRole (ch : Choreography) (name : String) : Option Role :=
  ch.roles.find? (fun role => role.name == name)  /- Lookup a role by name. -/

def actionLabels (ch : Choreography) : List String :=
  ch.actions.map (·.label)

/- Get actions that mention the supplied role for trace summaries. -/
def participatingActions (ch : Choreography) (roleName : String) : List Action :=
  ch.actions.filter (fun act =>
    Action.origin act == roleName || Action.destination act == roleName)

/- Ensure there are no duplicate roles. -/
def hasUniqueRoles (ch : Choreography) : Bool :=
  (roleNames ch).eraseDups == roleNames ch

/- Confirm every action references declared roles. -/
def hasValidActions (ch : Choreography) : Bool :=
  ch.actions.all (fun act =>
    let validOrigin := findRole ch (Action.origin act) |>.isSome
    let validDestination := findRole ch (Action.destination act) |>.isSome
    validOrigin && validDestination)

/- Produce a simple textual trace for diagnostics. -/
def describeRoleTrace (ch : Choreography) (roleName : String) : String :=
  let actions := participatingActions ch roleName
  let summary := actions.map fun act =>
    Action.label act
  if summary.isEmpty then
    s!"{roleName} has no actions"
  else
    String.intercalate ", " summary

def isWellFormed (ch : Choreography) : Bool :=
  hasUniqueRoles ch && hasValidActions ch

end Rumpsteak
