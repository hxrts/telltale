# V2 Work Plan: Remaining Proof Obligations

**Documentation:** Maintain `lean/RumpsteakV2/CODE_MAP.md` throughout this work (see Documentation Protocol)

---

## Summary

| Codebase | Axioms | Sorries | Status |
|----------|--------|---------|--------|
| Inductive   | 5 | 22 | Participation/Projectb axioms remain; StepProjection (14) and FullUnfold (8) need work |
| Coinductive | 7 | 1  | BisimDecidable compiles clean; 1 sorry in RoundtripWIP; μ-paco bridge pending |


----------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------


## Inductive Codebase

### Axiom Inventory (5 total)

| File | Count | Axioms |
|------|-------|--------|
| Participation.lean | 2 | `part_of2_iff_participates`, `participatesBranches_iff_part_of2` |
| Projectb.lean      | 2 | `projectb_trans`, `CProject_unguarded_trans` |
| DBBridge.lean      | 1 | `EQ2_subst_mu_comm_via_DB` |

### Sorry Inventory (22 total)

| File | Count | Description |
|------|-------|-------------|
| StepProjection.lean | 14 | `proj_trans_other_step_with_guard` and helper lemmas |
| FullUnfold.lean     | 8  | Mu-unfold and guardedness preservation |

### Remaining Work

**Participation.lean (2 axioms):**
- [ ] `part_of2_iff_participates` - Prove equivalence between participates and part_of2
- [ ] `participatesBranches_iff_part_of2` - Branch-level participation equivalence

**Projectb.lean (2 axioms):**
- [ ] `projectb_trans` - Prove projectb equals trans for well-formed protocols
- [ ] `CProject_unguarded_trans` - Show CProject handles unguarded types via trans

**DBBridge.lean (1 axiom):**
- [ ] `EQ2_subst_mu_comm_via_DB` - Port from `work/inductive/de_bruijn.lean` or prove via Barendregt convention

**StepProjection.lean (14 sorries):**
- [ ] Complete `proj_trans_other_step_with_guard` proof
- [ ] Prove receiver ≠ sender well-formedness condition
- [ ] Complete all case branches in step preservation

**FullUnfold.lean (8 sorries):**
- [ ] Prove mu-unfold preservation lemmas
- [ ] Complete guardedness preservation across unfolds


----------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------


## Coinductive Codebase

**Current status:** Coinductive pipeline unblocked (GlobalType.fullUnfoldIter fixed; BisimDecidable clean). Remaining blocker: μ-paco → EQ2C bridge for `RoundtripWIP.lean`. Next: formalize productivity/regularity hypothesis that lets `EQ2C_mu_paco` collapse to `EQ2C`, then wire into `EQ2CE_resolved'_implies_EQ2C`.

### Axiom Inventory (7 total)

All are intentional stubs with proofs in RoundtripWIP.lean:
- `nameOf`, `envOf` - name/environment generation
- `toCoind_toInductive_eq2ce` - round-trip in EQ2CE
- `toCoind_toInductive_eq2c_of_eq2ce`, `toCoind_toInductive_eq2c_of_backedge`, `toCoind_toInductive_eq2c_of_env` - EQ2C variants
- `toCoind_toInductive` - main round-trip theorem

### Sorry Inventory (1 executable)

| File | Sorry | Description |
|------|-------|-------------|
| RoundtripWIP.lean | 1 | Termination (`decreasing_by all_goals sorry`) |

### Remaining Work

**RoundtripWIP.lean termination (1 sorry):**

Current plan: Replace recursive termination with gpaco-based coinductive proof (no structural recursion).

Tasks:
- [ ] **Environment erasure (primary):** Implement gpaco/paco erasure proof from `work/coinductive/environment_erasure_problem.md` using existing `EQ2CMono`/`ObservableRelC`
- [x] **Mu-step generator scaffold:** Added `EQ2C_mu_step`/`EQ2CMuMono`/`EQ2C_mu_paco` and `EQ2C_paco ≤ EQ2C_mu_paco`
- [x] **Mu-step → obs-step (bounded):** Added `EQ2C_mu_paco_to_obs_of_bounds` + `EQ2C_mu_paco_to_obs`
- [ ] **Mu-step → obs-step (full):** Prove `EQ2C_mu_paco ≤ EQ2C_paco` (requires guardedness/closure assumptions)
- [ ] **Update for paco v0.1.3 gcofix:** Rework `EQ2CE_resolved'_to_gpaco` to guard-based `gpaco_clo_coind'` style
- [ ] **gpaco_clo observables:** Generalize `gpaco_clo_obs` to extract `ObservableRelC` from `gpaco_clo EQ2CMono mu_clo rr rr`
- [x] **BranchesRelC coercion:** Helper showing `BranchesRelC (gupaco_clo EQ2CMono mu_clo rr)` embeds properly
- [ ] **Guard-based gpaco μ-case strategy:** Decide how to handle μ-cases under `gpaco_clo_coind'`
- [ ] **Replace termination:** Prove `EQ2CE_resolved'_implies_EQ2C` via `gpaco_clo_final` or cofix; remove sorry

Notes:
- Avoid new EQ2C definitions; use existing `ObservableRelC`/`EQ2CMono` infrastructure
- Use `work/coinductive/` files for proof patterns only; don't re-define EQ2C/Bisim
- Port card-decrease termination tools only if toInductiveAux termination needs it
- Defer gfp-projection and lift/subst ports unless nameOf/envOf explicitly needs them


----------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------


## Documentation Protocol

After completing any major phase of work (finishing a file, eliminating axioms, proving key theorems):

1. **Update Axiom Inventory:** Revise axiom counts and sorry counts in CODE_MAP.md
2. **Add New Theorems:** Document location, statement, and purpose of new theorems
3. **Update Cross-References:** Add new theorems to topic-based and dependency indices
4. **Revise Dependency Diagrams:** Update ASCII dependency chains if structure changed
5. **Update File Sizes:** Run `wc -l` on modified files and update size reference table
6. **Commit Together:** Include CODE_MAP.md updates in the same commit as proof work

**Trigger Points:**
- Completing any proof phase in work/v2.md
- Eliminating any axiom or sorry
- Adding new files to RumpsteakV2/ or Coinductive/
- Major refactoring that changes module structure
- Monthly maintenance review

---

## Reference Files

| Directory/File | Purpose |
|----------------|---------|
| `lean/RumpsteakV2/CODE_MAP.md` | Codebase map - locations of all key proofs, lemmas, and theorems |
| `work/coinductive/` | Prototype implementations and proof sketches |
| `work/inductive/` | Coq-style proofs for porting reference |

**Key references:**
- `CODE_MAP.md` - Start here to find any theorem or understand proof dependencies
- `work/coinductive/005.lean` - Counterexample for flawed toInductiveAux
- `work/coinductive/006.lean` - Back-edge hypothesis pattern
- `work/coinductive/007.lean` - Environment erasure via paco
